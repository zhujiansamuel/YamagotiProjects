<!doctype html>
<html lang="zh">
<head>
    <meta charset="utf-8"/>
    <title>跨店铺曲线</title>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <script src="https://cdn.jsdelivr.net/npm/echarts@5/dist/echarts.min.js"></script>
    <style>
        :root {
            --w: 4080px;
        }

        body {
            font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", "PingFang SC", "Hiragino Sans", "Noto Sans CJK JP", Roboto, Arial;
            margin: 16px;
        }

        .wrap {
            max-width: var(--w);
            margin: 0 auto;

        }

        fieldset {
            border: 1px solid #e5e7eb;
            border-radius: 12px;
            padding: 12px;
            margin-bottom: 12px;
        }

        legend {
            padding: 0 6px;
            color: #111827;
            font-weight: 600;
        }

        .row3 {
            display: grid;
            grid-template-columns: 1.2fr .9fr .9fr;
            gap: 10px;
        }

        .row4 {
            display: grid;
            grid-template-columns: .7fr .7fr .5fr .5fr;
            gap: 10px;
            max-width: 1500px;
        }

        .row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        label {
            font-size: 12px;
            color: #374151;
            display: block;
            margin-bottom: 6px;
        }

        input[type="text"], input[type="datetime-local"] {
            width: 80%;
            padding: 8px 10px;
            border-radius: 10px;
            border: 1px solid #d1d5db;
            outline: none;
        }

        input:focus {
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, .15);
        }

        #shops {
            display: grid;
            grid-template-columns: repeat(4, minmax(0, 1fr));
            gap: 6px 10px;
            max-height: 180px;
            overflow: auto;
        }

        #shops label {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 13px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .btns {
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: wrap;
        }

        button {
            border: 0;
            padding: 9px 12px;
            border-radius: 10px;
            cursor: pointer;
            background: #111827;
            color: #fff;
        }

        button.secondary {
            background: #374151;
        }

        button.ghost {
            background: #f3f4f6;
            color: #111827;
        }

        #chart {
            width: 100%;
            height: 540px;
            border: 1px solid #e5e7eb;
            border-radius: 12px;
        }

        .muted {
            color: #6b7280;
            font-size: 12px;
        }

        .error {
            color: #b91c1c;
            font-size: 13px;
            margin-left: 8px;
        }

        .stat {
            font-size: 12px;
            white-space: pre-wrap;
            background: #fafafa;
            border: 1px solid #eee;
            border-radius: 8px;
            padding: 8px;
        }
    </style>
</head>
<body>
<div class="wrap">
    <h2 style="margin:6px 0 12px">店舗横断価格曲線</h2>


    <fieldset>
        <legend>選択条件</legend>
        <div class="row4">
            <div>
                <label>iPhoneの種類</label>
                <input id="iphone" list="iphone-list" type="text" placeholder="例：MG864J/A（プルダウンから選択可）"/>
                <div class="muted" id="iphone-hint" style="margin-top:4px">iPhone の候補を読み込み中…</div>
                <datalist id="iphone-list"></datalist>
            </div>

            <div>
                <label>iPhoneの型番（Part Number）</label>
                <input id="iphone" list="iphone-list" type="text" placeholder="例：MG864J/A（プルダウンから選択可）"/>
                <datalist id="iphone-list"></datalist>
                <div class="muted" id="iphone-hint" style="margin-top:4px">iPhone の候補を読み込み中…</div>
            </div>

            <div>
                <label>時間範囲 開始（JST）</label>
                <input id="start" type="datetime-local" step="60">
            </div>
            <div>
                <label>時間範囲 終了（JST）</label>
                <input id="end" type="datetime-local" step="60">
            </div>
        </div>

        <div style="margin-top:10px">
            <label>店舗</label>
            <div id="shops"></div>
            <div class="btns" style="margin-top:8px">
                <button class="ghost" id="select-all" type="button">すべて選択</button>
                <button class="ghost" id="clear-all" type="button">すべて解除</button>
            </div>
        </div>
    </fieldset>

    <div class="btns" style="margin:10px 0 8px">
        <button id="load" type="button">読み込み・描画</button>
        <button id="reset" class="secondary" type="button">表示をリセット</button>
        <span id="status" class="muted"></span><span id="err" class="error"></span>
    </div>

    <div id="chart"></div>

    <details style="margin-top:10px">
        <summary class="muted">デバッグ情報（店舗ごとの件数／フィルタ後件数／開始・終了時刻）</summary>
        <div id="stats" class="stat"></div>
    </details>
</div>


<script>
    /* ===================== 1) 固定颜色方案 ===================== */
    const LINE_PALETTE = [
        "#DD1133", /* 買取商店 */
        "#478CD8", /* 海峡通信 */
        "#B41524", /* 買取１丁目 */
        "#DD1133", /* モバイルミックス */
        "#278C46", /* 森森買取 */
        "#2DA9E8", /* 買取ルデヤ */
        "#E71534", /* 買取Wiki */
        "#F27474", /* 買取ホムラ */
        "#3952A6", /* ドラゴンモバイル- */
        "#E60012", /* モバステ- */
        "#20AECC", /* アキモバ- */
        "#0EC7D9", /* トゥインクル */
        "#FFF100", /* 家電市場-shop13 */
        "#DA7C66", /* 買取楽園-shop14 */
        "#1C4473", /* 買取当番-shop15 */
        "#0049A8", /* 携帯空間-shop16 */
        "#34C6F6", /* ゲストモバイル-shop17 */
        "#033F68", /* 買取オク-shop18 */
        /* #84cc16, 基础-19（保留空位） */
        "#C30D23", /* 毎日買取-shop20 */
    ];

    // 名称→固定色（模糊匹配），其余回退到调色板序号
    const SHOP_COLOR_RULES = [
        {match: /アキモバ/, color: "#20AECC"},
        {match: /トゥインクル/, color: "#0EC7D9"},
        {match: /モバイルミックス/, color: "#DD1133"},
        {match: /森森買取/, color: "#278C46"},
        {match: /ルデヤ/, color: "#2DA9E8"},
        {match: /ホムラ/, color: "#F27474"},
        {match: /ドラゴンモバイル/, color: "#3952A6"},
        {match: /モバステ/, color: "#E60012"},
        {match: /家電市場/, color: "#FFF100"},
        {match: /買取楽園/, color: "#DA7C66"},
        {match: /買取当番/, color: "#1C4473"},
        {match: /携帯空間/, color: "#0049A8"},
        {match: /ゲストモバイル/, color: "#34C6F6"},
        {match: /買取オク/, color: "#033F68"},
        {match: /毎日買取/, color: "#C30D23"},
        {match: /海峡通信/, color: "#478CD8"},
        {match: /買取１丁目/, color: "#B41524"},
        {match: /買取商店/, color: "#DD1133"},
        {match: /買取Wiki/, color: "#E71534"},
    ];

    function fixedColorFor(seriesName, indexFallback) {
        for (const rule of SHOP_COLOR_RULES) {
            if (rule.match.test(seriesName)) return rule.color;
        }
        return LINE_PALETTE[indexFallback % LINE_PALETTE.length];
    }

    const $ = id => document.getElementById(id);
    const fmtJPY = n => new Intl.NumberFormat('ja-JP', {
        style: 'currency',
        currency: 'JPY',
        maximumFractionDigits: 0
    }).format(n);
    const fmtJST = ts => new Date(ts).toLocaleString('ja-JP', {hour12: false});
    const WDAY = ['日', '月', '火', '水', '木', '金', '土'];

    /* ====== 常量：时间序列 API & SSE 路径 ====== */
    const SERIES_API_BASE = '/AppleStockChecker/purchasing-time-analyses-psta-compact/'; // ← 如需调整，改这条
    const BROADCAST_URL = '/events/notify_progress_all';                                  // SSE 路径

    /* ====== 运行态索引与状态 ====== */
    const SHOPS_INDEX = new Map();        // shopId -> shopName
    const IPHONE_ID_BY_PART = new Map();  // part_number -> iphone_id
    let ACTIVE_PART_NUMBER = '';
    let ACTIVE_IPHONE_ID = null;          // 当前选择的机型 id（来自 IPHONE_ID_BY_PART）
    let SELECTED_SHOP_IDS = new Set();    // 当前勾选的门店
    let liveES = null;

    function toIsoLocal(dtStr) {
        // <input type="datetime-local"> 通常形如 "2025-10-10T09:00"
        if (!dtStr || !/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}$/.test(dtStr)) return '';
        return `${dtStr}:00+09:00`;   // → "2025-10-10T09:00:00+09:00"
    }


    function toMillis(s) {
        const t = new Date(s).valueOf();
        return Number.isFinite(t) ? t : NaN;
    }

    function nearestPastMinuteMs(date = new Date()) {
        return Math.floor(date.getTime() / 60000) * 60000;
    }

    function buildURL(base, startIsoJST, endIsoJST, shopId, partNumber) {
        const sid = Number(shopId);
        if (!Number.isFinite(sid)) {
            console.warn('[buildURL] invalid shopId:', shopId, {startIsoJST, endIsoJST, partNumber});
            throw new Error('Invalid shop id');
        }
        if (!startIsoJST || !endIsoJST) {
            throw new Error('Invalid time range');
        }

        const u = new URL(base, location.origin);
        u.searchParams.set("start", startIsoJST);               // URLSearchParams 会把 + 编成 %2B
        u.searchParams.set("end", endIsoJST);
        u.searchParams.set("shop", String(sid));                // 若后端是 shop_id，这里改 "shop_id"
        u.searchParams.set("iphone__part_number", String(partNumber));
        return u.toString();
    }

    /* ============ 3) X 轴标签：竖排（月/日/（周）） ============ */
    function verticalTickFormatter(value /* ms */) {
        const d = new Date(value);
        const m = d.getMonth() + 1;
        const day = d.getDate();
        const w = WDAY[d.getDay()];
        return `${m}\n月\n${day}日\n（${w}）`;
    }

    /* ============ 4) 每天 9:00–20:00 markArea 背景（保留） ============ */
    function buildBusinessHoursMarkArea(startMs, endMs) {
        const oneDay = 24 * 3600 * 1000;
        const data = [];
        let d = new Date(startMs);
        d.setHours(0, 0, 0, 0);
        for (let t = d.valueOf(); t <= endMs + oneDay; t += oneDay) {
            const s = new Date(t);
            const s9 = new Date(s);
            s9.setHours(10, 0, 0, 0);
            const e20 = new Date(s);
            e20.setHours(20, 0, 0, 0);
            const s9ms = s9.valueOf(), e20ms = e20.valueOf();
            const left = Math.max(s9ms, startMs);
            const right = Math.min(e20ms, endMs);
            if (left < right) data.push([{xAxis: left}, {xAxis: right}]);
        }
        return {silent: true, itemStyle: {color: 'rgba(255,231,231,0.4)', opacity: 0.35}, data};
    }

    // --- ECharts ---
    const chart = echarts.init($('chart'));
    const baseOption = {
        animation: false,
        tooltip: {show: true, trigger: 'axis'},
        legend: {top: 8, left: 10, itemGap: 14},
        grid: {left: 16, right: 48, top: 40, bottom: 12},
        xAxis: {
            type: 'time',
            axisLabel: {formatter: verticalTickFormatter, lineHeight: 16, margin: 18},
            axisTick: {alignWithLabel: true}
        },
        yAxis: {type: 'value', position: 'right', name: 'JPY', scale: true},
        dataZoom: [
            {type: 'inside', xAxisIndex: [0]},
            {type: 'slider', xAxisIndex: [0], bottom: -2, height: 12, handleSize: 0}
        ],
        series: []
    };
    chart.setOption(baseOption);
    $('reset').addEventListener('click', () => chart.setOption(baseOption, true));
    window.addEventListener('resize', () => chart.resize());

    const API_BASE = '/AppleStockChecker';
    const ENDPOINT_SHOPS = `${API_BASE}/secondhand-shops/`;
    const ENDPOINT_IPHONES = `${API_BASE}/iphones/`;


    /* ========== 影子点/UI工具 ========== */

    // 取点的时间戳（ms）
    function _pointTs(item) {
        const v = Array.isArray(item) ? item : item?.value;
        return Array.isArray(v) ? v[0] : null;
    }

    // 是否为影子点
    function _isShadow(item) {
        return !Array.isArray(item) && item?.shadow === true;
    }

    // 确保顶部有一个摘要栏
    function _ensureShadowSummaryHost() {
        if (document.getElementById('shadow-summary')) return;
        const wrap = document.querySelector('.wrap');
        const bar = document.createElement('div');
        bar.id = 'shadow-summary';
        Object.assign(bar.style, {
            margin: '8px 0 6px',
            fontSize: '12px',
            display: 'flex',
            flexWrap: 'wrap',
            gap: '6px',
            alignItems: 'center'
        });
        const title = document.createElement('span');
        title.textContent = '最新影子値：';
        title.style.cssText = 'color:#6b7280;margin-right:6px;';
        bar.appendChild(title);
        wrap.insertBefore(bar, document.getElementById('chart'));
    }

    // 渲染“最新一分钟影子值”摘要（只看已勾选门店）
    function renderShadowSummary(targetMs) {
        _ensureShadowSummaryHost();
        const host = document.getElementById('shadow-summary');
        // 清空除标题外的节点
        [...host.childNodes].slice(1).forEach(n => host.removeChild(n));

        const opt = chart.getOption();
        const seriesArr = (opt.series || []).filter(s => {
            // 只看已勾选门店的系列（id: s:<shopId>）
            const m = String(s?.id || '').match(/^s:(\d+)$/);
            return m && SELECTED_SHOP_IDS.has(Number(m[1]));
        });

        // 收集当前分钟的影子值
        const items = [];
        for (const s of seriesArr) {
            const data = s.data || [];
            const item = data.find(pt => _pointTs(pt) === targetMs && _isShadow(pt));
            if (!item) continue;
            const v = item.value?.[1];
            const name = s.name || s.id;
            if (Number.isFinite(v)) items.push({name, v});
        }
        if (!items.length) {
            const span = document.createElement('span');
            span.textContent = '—（対象の影子点なし）';
            span.style.cssText = 'color:#9ca3af;';
            host.appendChild(span);
            return;
        }

        // 计算最大/最小
        let maxV = -Infinity, minV = Infinity;
        for (const it of items) {
            if (it.v > maxV) maxV = it.v;
            if (it.v < minV) minV = it.v;
        }

        // 逐项渲染
        for (const it of items) {
            const chip = document.createElement('span');
            chip.textContent = `${it.name}: ${fmtJPY(it.v)}`;
            const isMax = it.v === maxV, isMin = it.v === minV;
            Object.assign(chip.style, {
                padding: '2px 8px',
                borderRadius: '8px',
                background: isMax ? '#d93025' : (isMin ? '#0f9d58' : '#f3f4f6'),
                color: isMax || isMin ? '#fff' : '#111827',
                border: isMax || isMin ? '0' : '1px solid #e5e7eb'
            });
            host.appendChild(chip);
        }

        // 在右侧附上时间
        const timeLabel = document.createElement('span');
        timeLabel.textContent = ` @ ${new Date(targetMs).toLocaleTimeString('ja-JP', {hour12: false})}`;
        timeLabel.style.cssText = 'margin-left:8px;color:#6b7280;';
        host.appendChild(timeLabel);
    }

    /* ========== 工作时段背景（10:00-19:00 卡其色） ========== */
    function buildBusinessHoursMarkArea10to19(startMs, endMs) {
        const oneDay = 24 * 3600 * 1000;
        const data = [];
        let d0 = new Date(startMs);
        d0.setHours(0, 0, 0, 0);
        for (let t = d0.valueOf(); t <= endMs + oneDay; t += oneDay) {
            const s10 = new Date(t);
            s10.setHours(10, 0, 0, 0);
            const e19 = new Date(t);
            e19.setHours(19, 0, 0, 0);
            const left = Math.max(s10.valueOf(), startMs);
            const right = Math.min(e19.valueOf(), endMs);
            if (left < right) data.push([{xAxis: left}, {xAxis: right}]);
        }
        return {silent: true, itemStyle: {color: '#f0e68c', opacity: 0.35}, data};
    }

    // 叠加一个专用“背景系列”
    function applyWorkHoursOverlay(startMs, endMs) {
        if (!Number.isFinite(startMs) || !Number.isFinite(endMs) || startMs >= endMs) return;
        const markArea = buildBusinessHoursMarkArea10to19(startMs, endMs);
        chart.setOption({
            series: [{
                id: '__workhours__',
                type: 'line',
                data: [],
                markArea,
                silent: true,
                z: -10
            }]
        }, {notMerge: false, lazyUpdate: true});
    }


    // —— 更健壮的 loadShops —— //
    async function loadShops() {
        const box = $('shops');
        box.innerHTML = '';
        SHOPS_INDEX.clear();

        try {
            const resp = await fetch(ENDPOINT_SHOPS);
            if (!resp.ok) {
                const txt = await resp.text().catch(() => '');
                throw new Error(`HTTP ${resp.status} ${resp.statusText} ${txt.slice(0, 200)}`);
            }
            const payload = await resp.json();

            // 兼容数组 / results / items
            const items = Array.isArray(payload) ? payload
                : Array.isArray(payload?.results) ? payload.results
                    : Array.isArray(payload?.items) ? payload.items
                        : [];

            let invalidCount = 0;

            for (const s of items) {
                // 尝试多种 id 字段名
                const sidRaw = s?.id ?? s?.shop_id ?? s?.pk ?? s?.ID ?? s?.Id;
                const sid = Number(sidRaw);
                if (!Number.isFinite(sid)) {
                    invalidCount++;
                    // 调试：在控制台看到是哪条数据有问题
                    console.warn('[shops] skip invalid id item:', s);
                    continue; // 跳过没有有效 id 的项
                }

                // 名称字段也容错
                const sname = s?.name ?? s?.shop_name ?? s?.display_name ?? String(sid);

                // 用 DOM API 安全构建（避免 innerHTML 把 undefined 拼进去）
                const label = document.createElement('label');
                label.title = sname;

                const input = document.createElement('input');
                input.type = 'checkbox';
                input.value = String(sid);
                input.dataset.name = sname;
                input.dataset.shopId = String(sid);        // ★ 关键：标记有效门店
                input.id = `shop_${sid}`;

                const span = document.createElement('span');
                span.textContent = sname;

                label.appendChild(input);
                label.appendChild(span);
                box.appendChild(label);

                SHOPS_INDEX.set(sid, sname);
            }

            if (items.length === 0) {
                $('err').textContent = '店舗リストが空です（API 応答を確認してください）';
            }
            if (invalidCount > 0) {
                // 仅提示，不阻断
                console.warn(`[shops] skipped ${invalidCount} invalid entries (missing id)`);
            }
        } catch (e) {
            console.error(e);
            $('err').textContent = '店舗の読み込みに失敗しました（CORS / 認証 / 応答形式を確認）';
        }
    }

    async function loadIphones() {
        const dl = $('iphone-list');
        dl.innerHTML = '';
        IPHONE_ID_BY_PART.clear();
        try {
            const resp = await fetch(ENDPOINT_IPHONES);
            const items = await resp.json();
            for (const i of items) {
                const text = `${i.part_number} ｜ ${i.model_name} ${i.capacity_label} ｜ ${i.color}`;
                const opt = document.createElement('option');
                opt.value = i.part_number;
                opt.label = text;
                dl.appendChild(opt);
                if (i.id != null && i.part_number) {
                    IPHONE_ID_BY_PART.set(String(i.part_number), Number(i.id));
                }
            }
            $('iphone-hint').textContent = 'プルダウンから選択するか、part_number を直接入力してください';
        } catch (e) {
            $('iphone-hint').textContent = 'iPhone の読み込みに失敗しました（CORSまたはネットワーク）';
        }
    }

    $('select-all').addEventListener('click', () => {
        document.querySelectorAll('#shops input[type=checkbox][data-shop-id]').forEach(cb => cb.checked = true);
    });
    $('clear-all').addEventListener('click', () => {
        document.querySelectorAll('#shops input[type=checkbox][data-shop-id]').forEach(cb => cb.checked = false);
    });


    // ---- 取数（带埋点 & 可选鉴权） ----
    async function fetchOneShopSeries(base, startIsoJST, endIsoJST, shopId, shopName, partNumber) {
        const url = buildURL(base, startIsoJST, endIsoJST, shopId, partNumber);
        console.debug('[FETCH]', url);
        const headers = {"Accept": "application/json"};
        const token = localStorage.getItem('iphone:token'); // 如有鉴权，放入本地存储
        if (token) headers["Authorization"] = `Bearer ${token}`;

        const resp = await fetch(url, {headers});
        let rawText = '';
        if (!resp.ok) {
            try {
                rawText = await resp.text();
            } catch (_) {
            }
            throw new Error(`HTTP ${resp.status} ${resp.statusText} | ${rawText.slice(0, 200)}`);
        }

        // 兼容包裹层
        let payload = await resp.json();
        const data = Array.isArray(payload) ? payload
            : Array.isArray(payload?.results) ? payload.results
                : Array.isArray(payload?.items) ? payload.items
                    : [];

        // 字段名兜底（驼峰/蛇形/别名）
        const pick = (r, kList) => kList.find(k => k in r) ?? kList[0];
        const tKey = data[0] ? pick(data[0], ["Timestamp_Time", "timestamp_time", "timestamp", "ts", "t"]) : "Timestamp_Time";
        const pKey = data[0] ? pick(data[0], ["New_Product_Price", "new_product_price", "price", "value"]) : "New_Product_Price";
        const pnKey = data[0] ? pick(data[0], ["iphone", "iphone__part_number", "part_number"]) : "iphone";

        const rows = data.filter(r => !r[pnKey] || r[pnKey] === partNumber);

        const seriesData = rows
            .map(r => [new Date(r[tKey]).valueOf(), Number(r[pKey])])
            .filter(p => Number.isFinite(p[0]) && Number.isFinite(p[1]))
            .sort((a, b) => a[0] - b[0]);

        const firstT = seriesData[0]?.[0];
        const lastT = seriesData[seriesData.length - 1]?.[0];

        return {
            name: shopName,
            data: seriesData,
            stat: {shopId, shopName, returned: data.length, filtered: rows.length, firstT, lastT, url}
        };
    }

    // ---- 影子点：把最后一个点拉到最近整数分钟 ----
    function appendShadowToNowIfNeeded(seriesData) {
        if (!seriesData.length) return seriesData;
        const last = seriesData[seriesData.length - 1];
        const nowMin = nearestPastMinuteMs();
        if (last[0] < nowMin) {
            const hasNow = seriesData.length && (
                (Array.isArray(seriesData[seriesData.length - 1]) && seriesData[seriesData.length - 1][0] === nowMin) ||
                (seriesData[seriesData.length - 1]?.value?.[0] === nowMin)
            );
            if (!hasNow) {
                seriesData.push({
                    value: [nowMin, last[1]],
                    symbol: 'emptyCircle',
                    symbolSize: 6,
                    shadow: true,
                    src_ts: last[0]
                });
            }
        }
        return seriesData;
    }

    // === 强制增长：每分钟末端追加一个点（仅对已勾选门店） ===
    let LAST_FORCED_MINUTE_MS = null;   // 记录上一次强制追加的分钟（ms）
    let AUTO_GROW_TIMER = null;         // 定时器句柄
    const FORCE_GROW_INTERVAL_MS = 5000; // 每 5 秒检查一次是否到新分钟

    // 从 series.id = "s:<shopId>" 取 shopId
    function _seriesShopId(series) {
        const m = String(series?.id || '').match(/^s:(\d+)$/);
        return m ? Number(m[1]) : null;
    }


    /** 在 targetMs 这个分钟，对已勾选门店的曲线“强制增长一个末端点”
     *  - 若该分钟已有点（真实或影子）则跳过该线
     *  - 否则从该线历史中找 <= targetMs 的最近值复制，追加一个 {shadow:true, forced:true} 点
     *  - 同步把 xAxis.max 推进到 targetMs（若小于）
     */
    function forceGrowAtMinute(targetMs) {
        if (!SELECTED_SHOP_IDS || SELECTED_SHOP_IDS.size === 0) return;

        const opt = chart.getOption();
        const seriesArr = (opt.series || []).filter(s => {
            const m = String(s?.id || '').match(/^s:(\d+)$/);
            return m && SELECTED_SHOP_IDS.has(Number(m[1]));
        });

        const patches = [];
        for (const s of seriesArr) {
            let data = (s.data || []).slice();

            // 若该分钟已有点（真实或影子），跳过
            if (data.some(item => _pointTs(item) === targetMs)) continue;

            // 找 <= targetMs 的最近历史真实值/已有值
            let lastTs = null, lastPrice = null;
            for (let i = data.length - 1; i >= 0; i--) {
                const vv = Array.isArray(data[i]) ? data[i] : data[i]?.value;
                const t = Array.isArray(vv) ? vv[0] : null, y = Array.isArray(vv) ? vv[1] : null;
                if (t != null && y != null && t <= targetMs) {
                    lastTs = t;
                    lastPrice = y;
                    break;
                }
            }
            if (lastPrice == null) continue;

            // ① 先清理“旧的影子点”
            data = data.filter(item => !(_isShadow(item) && _pointTs(item) < targetMs));

            // ② 追加“本分钟影子点”
            data.push({
                value: [targetMs, lastPrice], shadow: true, forced: true, src_ts: lastTs,
                symbol: 'emptyCircle', symbolSize: 6
            });

            // 排序
            data.sort((a, b) => (_pointTs(a) - _pointTs(b)));

            patches.push({id: s.id, data});
        }

        if (patches.length) {
            // 推进 X 轴右界到 targetMs
            const xa = (opt.xAxis && opt.xAxis[0]) || {};
            const newMax = Math.max(Number(xa.max || 0) || 0, targetMs);
            chart.setOption({xAxis: [{max: newMax}], series: patches}, {notMerge: false, lazyUpdate: true});
            // 刷新摘要
            renderShadowSummary(targetMs);
        }
    }


    /** 定时检查是否进入新分钟：满足以下条件则强制增长
     *  - 现在整分 > LAST_FORCED_MINUTE_MS
     *  - 且 “实际结束时间”（min(选定 end, 现在整分)）距离现在 ≤ 2 分钟
     */
    function startAutoForceGrow() {
        if (AUTO_GROW_TIMER) clearInterval(AUTO_GROW_TIMER);
        LAST_FORCED_MINUTE_MS = nearestPastMinuteMs(); // 初始化为当前整分（避免刷新瞬间重复加点）
        AUTO_GROW_TIMER = setInterval(() => {
            const nowMin = nearestPastMinuteMs();
            if (nowMin <= LAST_FORCED_MINUTE_MS) return;

            const effEnd = _effectiveEndMs();
            if (Math.abs(Date.now() - effEnd) <= 2 * 60 * 1000) {
                forceGrowAtMinute(nowMin);
                LAST_FORCED_MINUTE_MS = nowMin;
            } else {
                // 不在“接近现在”窗口，不增长，但同步更新 LAST_FORCED_MINUTE_MS 防止追补过多
                LAST_FORCED_MINUTE_MS = nowMin;
            }
        }, FORCE_GROW_INTERVAL_MS);
    }


    let liveWS = null;

    function getAccessToken() {
        // 1) URL 查询：?access=...  （方便临时传）
        const fromQuery = new URLSearchParams(location.search).get('access');
        if (fromQuery) return fromQuery.trim();

        // 2) meta 标签：<meta name="psta-access" content="...">
        const meta = document.querySelector('meta[name="psta-access"]');
        if (meta?.content) return meta.content.trim();

        // 3) body data- 属性：<body data-access="...">
        const fromData = document.body?.dataset?.access;
        if (fromData) return fromData.trim();

        // 4) Cookie：access=...  （注意非 HttpOnly 才能读，HttpOnly 则由服务端在 WS 层校验）
        const m = document.cookie.match(/(?:^|;\s*)access=([^;]+)/);
        if (m) return decodeURIComponent(m[1]).trim();

        // 5) localStorage（你已在用）
        const ls = localStorage.getItem('iphone:token');
        if (ls) return ls.trim();

        return '';
    }


    function connectLive() {
        // 1) 取 token（localStorage 优先，data-* 备选）
        const access =
            (localStorage.getItem('iphone:token') || '').trim() ||
            (document.body.dataset?.access || '').trim();


        // 2) 目标 host：你可以用固定 ngrok 域名，或用当前站点
        //    如果你的后端不和前端同域，建议固定 ngrok 域名，避免 Origin 不匹配迷惑
        const WS_HOST = 'yamaguti.ngrok.io'; // ← 如需同域改成 location.host
        const scheme = 'wss';                 // ngrok 一般用 wss
        const wsUrl = `${scheme}://${WS_HOST}/ws/stream/psta/?token=${encodeURIComponent(access)}`;

        try {
            if (liveWS) {
                try {
                    liveWS.close();
                } catch (_) {
                }
            }

            liveWS = new WebSocket(wsUrl);


            liveWS.onmessage = (ev) => {
                // 可能是大 JSON 或 NDJSON，逐条尝试解析
                const chunks = typeof ev.data === 'string' ? ev.data.split(/\r?\n/).filter(Boolean) : [];
                for (const txt of chunks.length ? chunks : [ev.data]) {
                    if (typeof txt !== 'string') continue;
                    try {
                        const msg = JSON.parse(txt);

                        if (msg?.status === 'done' && msg?.chart_delta?.series_delta) {
                            applyChartDelta(msg.chart_delta);

                        } else if (msg?.type === 'chart_update' && msg?.series_delta) {
                            applyChartDelta(msg);
                        }
                    } catch { /* 忽略无法解析的行 */
                    }
                }
            };

            liveWS.onerror = (e) => {
                console.warn('[WS] error', e);
            };

            liveWS.onclose = (e) => {
                // 简单重连（如需可加指数退避）
                setTimeout(connectLive, 3000);
            };
        } catch (e) {
            console.error('[WS] connect failed', e);
        }
    }

    function onBroadcast(msg) {
        if (msg?.status === 'running') {
            // 可选：显示进度
            $('status').textContent = `処理中… ${msg.timestamp} / バケット: ${msg.buckets}`;
            return;
        }
        if (msg?.status === 'done' && msg?.chart_delta?.series_delta) {
            applyChartDelta(msg.chart_delta);
            ensureEdgePointForSelectedShops(msg.chart_delta.timestamp || null);

            const tIso = msg.chart_delta.timestamp || null;
            if (tIso) forceGrowAtMinute(new Date(tIso).getTime());
            return;
        } else if (msg?.type === 'chart_update' && msg?.series_delta) {
            applyChartDelta(msg); // 如果你在子任务阶段也做了中间广播
            ensureEdgePointForAllSeries(msg.timestamp /* 如果有 */);
        }
    }

    function ensureSeriesByShop(shopId, name) {
        const id = `s:${shopId}`;
        const opt = chart.getOption();
        const arr = opt.series || [];
        if (arr.findIndex(s => s.id === id) >= 0) return id;

        const color = fixedColorFor(name, arr.length);
        arr.push({
            id, name,
            type: 'line',
            showSymbol: false,
            smooth: 0.15,
            emphasis: {focus: 'series'},
            lineStyle: {width: 2, color},
            itemStyle: {color},
            data: []
        });
        chart.setOption({series: arr, legend: {data: arr.map(s => s.name)}});
        return id;
    }

    function applyChartDelta(delta) {
        if (!delta || !Array.isArray(delta.series_delta)) return;

        const touched = [];

        for (const sd of delta.series_delta) {
            // ★ 仅接收当前选择的 iPhone（patch 1/3）
            if (ACTIVE_IPHONE_ID && Number(sd.iphone_id) !== Number(ACTIVE_IPHONE_ID)) continue;

            const shopId = Number(sd.shop_id);
            if (!SELECTED_SHOP_IDS.has(shopId)) continue; // 仅更新当前勾选的门店

            const shopName = SHOPS_INDEX.get(shopId) || `#${shopId}`;
            const id = ensureSeriesByShop(shopId, shopName);

            const opt = chart.getOption();
            const seriesArr = opt.series || [];
            const idx = seriesArr.findIndex(s => s.id === id);
            const cur = (idx >= 0 ? seriesArr[idx].data : []) || [];

            // 建立 ts->索引 的索引，并标记是否是影子点
            const indexByTs = new Map();
            cur.forEach((item, i) => {
                const v = Array.isArray(item) ? item : item?.value;
                const t = Array.isArray(v) ? v[0] : undefined;
                const isShadow = !!(item && item.shadow === true);
                if (Number.isFinite(t)) indexByTs.set(t, {idx: i, isShadow});
            });

            const patch = cur.slice();

            for (const p of (sd.points || [])) {
                const t = toMillis(p.t);
                const y = Number(p.price);
                if (!Number.isFinite(t) || !Number.isFinite(y)) continue;

                const curAtT = indexByTs.get(t);
                if (p.shadow) {
                    if (curAtT && !curAtT.isShadow) continue; // 有真实点就忽略影子
                    const item = {
                        value: [t, y],
                        symbol: 'emptyCircle',
                        symbolSize: 6,
                        shadow: true,
                        src_ts: p.src_t || null
                    };
                    if (curAtT) patch[curAtT.idx] = item; else {
                        indexByTs.set(t, {idx: patch.length, isShadow: true});
                        patch.push(item);
                    }
                } else {
                    const item = [t, y]; // 真实点用数组，渲染更快
                    if (curAtT) {
                        patch[curAtT.idx] = item;
                        indexByTs.set(t, {idx: curAtT.idx, isShadow: false});
                    } else {
                        indexByTs.set(t, {idx: patch.length, isShadow: false});
                        patch.push(item);
                    }
                    // 确保把同刻影子移掉（如果有）
                    const shadowIdx = patch.findIndex(x => !Array.isArray(x) && x?.shadow === true && x?.value?.[0] === t);
                    if (shadowIdx >= 0) patch.splice(shadowIdx, 1);
                }
            }

            patch.sort((a, b) => {
                const va = Array.isArray(a) ? a : a.value;
                const vb = Array.isArray(b) ? b : b.value;
                return va[0] - vb[0];
            });
            if (patch.length > MAX_POINTS_PER_SERIES) patch.splice(0, patch.length - MAX_POINTS_PER_SERIES);

            chart.setOption({series: [{id, data: patch}]}, {notMerge: false, lazyUpdate: true});
            touched.push(id);
        }
    }

    function putStats(stats) {
        const div = $('stats');
        const lines = stats.map(s => {
            const t0 = s.firstT ? new Date(s.firstT).toLocaleString() : '-';
            const t1 = s.lastT ? new Date(s.lastT).toLocaleString() : '-';
            return `#${s.shopId} ${s.shopName}\n  取得件数: ${s.returned}\n  フィルタ後の点数: ${s.filtered}\n  開始/終了時刻: ${t0}  →  ${t1}\n  URL: ${s.url}\n`;
        });
        div.textContent = lines.join('\n');
    }

    async function loadAndPlot() {
        $('status').textContent = '読み込み中…';
        $('err').textContent = '';
        $('stats').textContent = '';

        const base = SERIES_API_BASE; // ★ 不再依赖 $('base')，固定你的序列 API
        const part = $('iphone').value.trim();
        const startIso = toIsoLocal($('start').value);
        const endIso = toIsoLocal($('end').value);

        SELECTED_START_MS = startIso ? new Date(startIso).getTime() : null;
        SELECTED_END_MS = endIso ? new Date(endIso).getTime() : null;

// 在 setOption 渲染成功之后（你已有）：
        startAutoForceGrow(); // ← 开启每分钟强制增长

        if (!base || !startIso || !endIso) {
            $('err').textContent = 'ベースURLと時間範囲を入力してください';
            $('status').textContent = '';
            return;
        }
        if (!part) {
            $('err').textContent = 'part_number を入力してください';
            $('status').textContent = '';
            return;
        }

        const shopCbs = Array.from(
            document.querySelectorAll('#shops input[type=checkbox][data-shop-id]:checked')
        ).filter(cb => /^\d+$/.test(String(cb.value)));
        if (shopCbs.length === 0) {
            $('err').textContent = '少なくとも1店舗を選択してください';
            $('status').textContent = '';
            return;
        }

        // ★ 记录活动条件（patch 2/3）
        ACTIVE_PART_NUMBER = part;
        ACTIVE_IPHONE_ID = IPHONE_ID_BY_PART.get(part) ?? null;
        SELECTED_SHOP_IDS = new Set(shopCbs.map(cb => Number(cb.value)));

        try {
            const tasks = shopCbs.map(cb => {
                const id = cb.value;
                const name = cb.getAttribute('data-name') || id;
                return fetchOneShopSeries(base, startIso, endIso, id, name, part)
                    .then(r => ({ok: true, r}))
                    .catch(e => ({ok: false, name, e}));
            });

            const results = await Promise.all(tasks);
            const series = [];
            const failed = [];
            const stats = [];

            let idxFallback = 0;
            for (const it of results) {
                if (it.ok) {
                    stats.push(it.r.stat);
                    const shopIdNum = Number(it.r.stat.shopId);
                    const name = it.r.name;
                    const color = fixedColorFor(name, idxFallback++);

                    // ★ 首屏：若最后点早于最近整数分钟，补一个影子点（patch 3/3）
                    const data = appendShadowToNowIfNeeded(it.r.data.slice());

                    series.push({
                        id: `s:${shopIdNum}`,     // 稳定 id，方便后续增量定点刷新
                        name,
                        type: 'line',
                        showSymbol: false,
                        smooth: 0.15,
                        emphasis: {focus: 'series'},
                        lineStyle: {width: 2, color},
                        itemStyle: {color},
                        data
                    });
                } else {
                    failed.push(it.name);
                }
            }

            putStats(stats);

            const anyPoints = series.some(s => s.data.length > 0);
            const subTitle = `iPhone：${part} ｜ ${new Date(startIso).toLocaleString()} → ${new Date(endIso).toLocaleString()}`;

            if (!anyPoints) {
                chart.clear();
                chart.setOption({
                    title: {text: 'データなし', subtext: subTitle, left: 'center', top: 'middle'}
                });
                $('status').textContent = 'データがありません。part_number と時間範囲が選択した店舗の記録をカバーしているか確認してください。';
                return;
            }

            chart.setOption({
                tooltip: {
                    trigger: 'axis',
                    axisPointer: {type: 'cross'},
                    formatter: function (params) {
                        if (!params || !params.length) return '';
                        const head = new Date(params[0].axisValue).toLocaleString('ja-JP', {hour12: false});
                        const lines = [head];
                        for (const p of params) {
                            const v = Array.isArray(p.value) ? p.value[1] : (p.data?.value?.[1] ?? p.value);
                            const isShadow = p.data && p.data.shadow === true;
                            let line = `${p.seriesName}: ${fmtJPY(v)}`;
                            if (isShadow) {
                                const src = p.data.src_ts ? new Date(p.data.src_ts).toLocaleString('ja-JP', {hour12: false}) : '';
                                line += src ? `（影子 ← ${src}）` : `（影子）`;
                            }
                            lines.push(line);
                        }
                        return lines.join('<br>');
                    }
                },
                toolbox: {show: true, feature: {saveAsImage: {}}},
                legend: {data: series.map(s => s.name)},
                xAxis: {
                    type: 'time',
                    axisLabel: {formatter: verticalTickFormatter, lineHeight: 16, margin: 18},
                    axisTick: {alignWithLabel: true}
                },
                yAxis: {
                    type: 'value',
                    position: 'right',
                    name: 'JPY',
                    scale: true
                },
                series
            }, true);
// 叠加工作时段背景（10:00–19:00）
applyWorkHoursOverlay(SELECTED_START_MS, SELECTED_END_MS);
// 首屏也渲染一次“最新影子摘要”（用当前最近整分）
renderShadowSummary(nearestPastMinuteMs());
            $('status').textContent = `完了：${series.length} 店舗${failed.length ? `／失敗：${failed.join(', ')}` : ''}`;
        } catch (e) {
            $('err').textContent = '読み込みに失敗しました：' + e.message;
            $('status').textContent = '';
            console.error(e);
        }
    }

    $('load').addEventListener('click', loadAndPlot);


    // 选中时窗（全局缓存）
    let SELECTED_START_MS = null;
    let SELECTED_END_MS = null;

    // 获取“图表实际结束时间”（毫秒）：min(所选end, 最近整数分钟)
    function getEffectiveEndMs() {
        const nowMin = nearestPastMinuteMs();
        const endMs = SELECTED_END_MS ?? nowMin;
        return Math.min(endMs, nowMin);
    }

    // —— 轻量 toast —— //
    function showToast(txt) {
        let div = document.getElementById('psta-toast');
        if (!div) {
            div = document.createElement('div');
            div.id = 'psta-toast';
            Object.assign(div.style, {
                position: 'fixed', right: '16px', top: '16px', zIndex: 99999,
                background: 'rgba(30, 41, 59, .95)', color: '#e2e8f0',
                padding: '8px 12px', borderRadius: '10px', border: '1px solid #334',
                font: '12px/1.4 ui-monospace, SFMono-Regular, Menlo, Consolas, monospace',
                boxShadow: '0 8px 24px rgba(0,0,0,.25)', transition: 'opacity .2s'
            });
            document.body.appendChild(div);
        }
        div.textContent = txt;
        div.style.opacity = '1';
        setTimeout(() => {
            div.style.opacity = '0';
        }, 1000); // 1 秒消失
    }

    // —— 闪烁层：在 targetMs 位置做 1s 涟漪特效 —— //
    function flashAtMinute(targetMs, seriesIds = []) {
        const opt = chart.getOption();
        const baseSeries = opt.series || [];
        const points = [];

        for (const id of seriesIds) {
            const s = baseSeries.find(x => x.id === id);
            if (!s) continue;
            // 取该系列的颜色
            const color = (s.itemStyle && s.itemStyle[0]?.color) || s.itemStyle?.color || s.lineStyle?.color;
            points.push({
                value: [targetMs, null],  // y 值不重要，effectScatter 不会用
                itemStyle: color ? {color} : undefined
            });
        }
        if (!points.length) return;

        const flashSeries = {
            id: 'psta-flash-layer',
            type: 'effectScatter',
            zlevel: 10,
            symbolSize: 10,
            rippleEffect: {scale: 3, brushType: 'stroke'},
            data: points,
            xAxisIndex: 0, yAxisIndex: 0
        };

        // 添加闪烁层
        chart.setOption({series: [flashSeries]}, {notMerge: false, lazyUpdate: true});
// 记录选择的 end，用于“实际结束时间”的判定
        SELECTED_END_MS = endIso ? new Date(endIso).getTime() : null;

// ...你原来的 chart.setOption(...) 之后：
        ensureEdgePointForSelectedShops(null); // 用最近整分作为目标分钟强制刷新边界
        // 1 秒后移除
        setTimeout(() => {
            const cur = chart.getOption().series || [];
            const remain = cur.filter(s => s.id !== 'psta-flash-layer');
            chart.setOption({series: remain}, {notMerge: true, lazyUpdate: true});
        }, 1000);
    }

    // —— 核心：确保在 targetMinute 每条线都有一个点（若缺则补影子），并提示 —— //
    function ensureEdgePointForAllSeries(targetIso) {
        const targetMs = targetIso ? new Date(targetIso).getTime() : nearestPastMinuteMs();
        const effEnd = getEffectiveEndMs();
        const now = Date.now();

        // 仅当 "实际结束时间" 距现在 ≤ 2 分钟 才触发
        if (Math.abs(now - effEnd) > 2 * 60 * 1000) return;

        const opt = chart.getOption();
        const seriesArr = (opt.series || []).filter(s => String(s.id || '').startsWith('s:'));
        const touchedIds = [];
        const patches = [];

        seriesArr.forEach(s => {
            const data = (s.data || []).slice();
            // 是否已有 targetMs 的点
            const hasAt = data.some(item => {
                const v = Array.isArray(item) ? item : item?.value;
                return Array.isArray(v) && v[0] === targetMs;
            });
            if (hasAt) return;

            // 找 <= targetMs 的最近点
            let lastTs = null, lastPrice = null;
            for (let i = data.length - 1; i >= 0; i--) {
                const v = Array.isArray(data[i]) ? data[i] : data[i]?.value;
                const t = Array.isArray(v) ? v[0] : null;
                const y = Array.isArray(v) ? v[1] : null;
                if (t != null && y != null && t <= targetMs) {
                    lastTs = t;
                    lastPrice = y;
                    break;
                }
            }
            if (lastPrice == null) return; // 没有历史值就不补

            // 追加影子点
            data.push({
                value: [targetMs, lastPrice],
                shadow: true,
                src_ts: lastTs,
                symbol: 'emptyCircle',
                symbolSize: 6
            });

            // 时间排序 & 裁剪可选（通常数据量不大可略）
            data.sort((a, b) => {
                const va = Array.isArray(a) ? a : a.value;
                const vb = Array.isArray(b) ? b : b.value;
                return va[0] - vb[0];
            });

            patches.push({id: s.id, data});
            touchedIds.push(s.id);
        });

        if (patches.length) {
            chart.setOption({series: patches}, {notMerge: false, lazyUpdate: true});
            flashAtMinute(targetMs, touchedIds);
            showToast(`+${patches.length} 系列补点 @ ${new Date(targetMs).toLocaleTimeString('ja-JP', {hour12: false})}`);
        }
    }


    // =============== LiveLog（右下角直播调试面板）================
    const LiveLog = (() => {
        let root, body, counters, paused = false, maxLines = 500;
        let stat = {total: 0, running: 0, done: 0, chartSeries: 0, chartPoints: 0, shadowPoints: 0, last: ''};

        function el(tag, attrs = {}, children = []) {
            const e = document.createElement(tag);
            for (const [k, v] of Object.entries(attrs)) {
                if (k === 'style') Object.assign(e.style, v);
                else if (k.startsWith('on') && typeof v === 'function') e.addEventListener(k.substring(2), v);
                else e.setAttribute(k, v);
            }
            for (const c of [].concat(children)) e.appendChild(typeof c === 'string' ? document.createTextNode(c) : c);
            return e;
        }

        function fmtTime(d = new Date()) {
            return d.toLocaleString('ja-JP', {hour12: false});
        }

        function render() {
            if (root) return;
            const css = `
      .ll-box{position:fixed;right:12px;bottom:12px;width:420px;max-height:50vh;z-index:99999;
        background:#0b1020;color:#e9eef9;border:1px solid #334;border-radius:12px;box-shadow:0 6px 24px rgba(0,0,0,.25);font:12px/1.4 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;}
      .ll-head{display:flex;gap:8px;align-items:center;padding:8px 10px;border-bottom:1px solid #223;}
      .ll-head b{font-weight:700}
      .ll-pill{display:inline-block;padding:2px 8px;border-radius:9999px;background:#1a2540;color:#cde}
      .ll-btn{cursor:pointer;border:1px solid #345;background:#162036;color:#cde;border-radius:6px;padding:4px 8px}
      .ll-btn:hover{filter:brightness(1.1)}
      .ll-body{padding:6px 8px;max-height:calc(50vh - 44px);overflow:auto;white-space:pre-wrap}
      .ll-row{padding:2px 0;border-bottom:1px dashed #243}
      .ll-row .t{color:#9ad}
      .ll-row.warn{color:#ffc36b}
      .ll-row.err{color:#ff9090}
      .ll-meta{font-size:11px;color:#9bb}
    `;
            document.head.appendChild(el('style', {}, css));
            body = el('div', {class: 'll-body', id: 'll-body'});

            counters = el('div', {class: 'll-meta', id: 'll-meta'});
            const title = el('div', {class: 'll-head'}, [
                el('b', {}, 'Live Debug'),
                el('span', {class: 'll-pill', id: 'll-pill-msg'}, 'msg: 0'),
                el('span', {class: 'll-pill', id: 'll-pill-run'}, 'running: 0'),
                el('span', {class: 'll-pill', id: 'll-pill-done'}, 'done: 0'),
                el('span', {style: {marginLeft: 'auto'}}, ''),
                el('button', {
                    class: 'll-btn', onclick: () => {
                        paused = !paused;
                        updateMeta();
                    }
                }, '⏸/▶'),
                el('button', {
                    class: 'll-btn', onclick: () => {
                        body.textContent = '';
                        updateMeta();
                    }
                }, 'Clear'),
                el('button', {class: 'll-btn', onclick: copyAll}, 'Copy')
            ]);

            root = el('div', {class: 'll-box', id: 'live-log'}, [title, counters, body]);
            document.body.appendChild(root);
            updateMeta();
        }

        function copyAll() {
            const txt = [...body.querySelectorAll('.ll-row')].map(n => n.textContent).join('\n');
            navigator.clipboard.writeText(txt).catch(() => {
            });
        }

        function updateMeta() {
            const $ = id => root.querySelector(id);
            $('#ll-pill-msg').textContent = `msg: ${stat.total}`;
            $('#ll-pill-run').textContent = `running: ${stat.running}`;
            $('#ll-pill-done').textContent = `done: ${stat.done}`;
            counters.textContent =
                `series: ${stat.chartSeries} | points: ${stat.chartPoints} (shadow: ${stat.shadowPoints})` +
                `   last: ${stat.last || '-'}` + (paused ? '   [PAUSED]' : '');
        }

        function pushLine(text, cls = '') {
            const row = el('div', {class: `ll-row ${cls}`}, [
                el('span', {class: 't'}, `[${fmtTime()}] `),
                text
            ]);
            body.appendChild(row);
            // 限制行数
            const rows = body.querySelectorAll('.ll-row');
            if (rows.length > maxLines) for (let i = 0; i < rows.length - maxLines; i++) rows[i].remove();
            if (!paused) body.scrollTop = body.scrollHeight;
        }

        // 公开 API
        return {
            init(opts = {}) {
                maxLines = opts.maxLines ?? maxLines;
                render();
            },
            info(msg) {
                stat.total++;
                stat.last = fmtTime();
                pushLine(String(msg));
                updateMeta();
            },
            warn(msg) {
                stat.total++;
                stat.last = fmtTime();
                pushLine(String(msg), 'warn');
                updateMeta();
            },
            error(msg) {
                stat.total++;
                stat.last = fmtTime();
                pushLine(String(msg), 'err');
                updateMeta();
            },
            /** 收到任意广播（原始 payload） */
            event(payload) {
                stat.total++;
                stat.last = fmtTime();
                if (payload?.status === 'running') stat.running++;
                if (payload?.status === 'done') stat.done++;
                const brief = payload?.status === 'running'
                    ? `RUN ${payload.timestamp} buckets=${payload.buckets}`
                    : payload?.status === 'done'
                        ? `DONE ts=${payload?.summary?.timestamp || payload?.chart_delta?.timestamp} job=${payload?.chart_delta?.job_id || '-'}`
                        : `MSG`;
                pushLine(brief + (payload?.status === 'done' ? '' : ''));
                updateMeta();
            },
            /** 收到 chart_delta（统计 series / points / shadow） */
            delta(chartDelta) {
                if (!chartDelta?.series_delta) return;
                let series = 0, points = 0, shadows = 0;
                for (const s of chartDelta.series_delta) {
                    series++;
                    for (const p of (s.points || [])) {
                        points++;
                        if (p.shadow) shadows++;
                    }
                }
                stat.chartSeries = series;
                stat.chartPoints = points;
                stat.shadowPoints = shadows;
                stat.last = fmtTime();
                pushLine(`Δ series=${series} points=${points} shadow=${shadows}`);
                updateMeta();
            }
        };
    })();


    // 从系列 id "s:<shopId>" 提取数字 shopId
    function seriesShopId(series) {
        const m = String(series?.id || '').match(/^s:(\d+)$/);
        return m ? Number(m[1]) : null;
    }

    // 实际结束时间：min(用户选的 end, 最近整分)
    function _effectiveEndMs() {
        const nowMin = nearestPastMinuteMs();
        return Math.min(SELECTED_END_MS ?? nowMin, nowMin);
    }

    /** 只对已勾选门店强制刷新边界分钟：
     *  targetIso：优先用后端广播的 timestamp（ISO）；没有就用最近整分
     *  规则：若该分钟无点，取该线 <= 该分钟最近的历史点价格补一个“影子点”（emptyCircle）
     */
    function ensureEdgePointForSelectedShops(targetIso) {
        if (!SELECTED_SHOP_IDS || SELECTED_SHOP_IDS.size === 0) return;

        const targetMs = targetIso ? new Date(targetIso).getTime() : nearestPastMinuteMs();
        const effEnd = (function () {
            const nowMin = nearestPastMinuteMs();
            return Math.min(SELECTED_END_MS ?? nowMin, nowMin);
        })();
        if (Math.abs(Date.now() - effEnd) > 2 * 60 * 1000) return;

        const opt = chart.getOption();
        const seriesArr = (opt.series || []).filter(s => {
            const m = String(s?.id || '').match(/^s:(\d+)$/);
            return m && SELECTED_SHOP_IDS.has(Number(m[1]));
        });

        const patches = [];
        for (const s of seriesArr) {
            let data = (s.data || []).slice();

            // 若该分钟已有点（真实或影子），跳过
            if (data.some(item => _pointTs(item) === targetMs)) continue;

            // 找 <= targetMs 的最近历史值
            let lastTs = null, lastPrice = null;
            for (let i = data.length - 1; i >= 0; i--) {
                const vv = Array.isArray(data[i]) ? data[i] : data[i]?.value;
                const t = Array.isArray(vv) ? vv[0] : null, y = Array.isArray(vv) ? vv[1] : null;
                if (t != null && y != null && t <= targetMs) {
                    lastTs = t;
                    lastPrice = y;
                    break;
                }
            }
            if (lastPrice == null) continue;

            // ① 清理旧影子
            data = data.filter(item => !(_isShadow(item) && _pointTs(item) < targetMs));
            // ② 追加本分钟影子
            data.push({
                value: [targetMs, lastPrice], shadow: true, src_ts: lastTs,
                symbol: 'emptyCircle', symbolSize: 6
            });

            data.sort((a, b) => (_pointTs(a) - _pointTs(b)));
            patches.push({id: s.id, data});
        }

        if (patches.length) {
            chart.setOption({series: patches}, {notMerge: false, lazyUpdate: true});
            renderShadowSummary(targetMs);
        }
    }

    (function initDefaults() {
        $('start').value = "2025-10-01T10:00";
        $('end').value = "2025-10-20T10:00";
        loadShops();
        loadIphones();
        $('iphone').placeholder = "例：MG864J/A";
        connectLive(); // 开启 SSE 订阅
    })();
</script>
</body>
</html>
